\chapter{Security battlecards}
\label{app:battlecards}

\battlecard{SonarLint by SonarSource}{\url{https://www.sonarlint.org/}}{
\label{bc:sonarlint}
SonarLint is a free \gls{ide} plugin that focuses on code quality. As explained in this work code quality and code security are often related and hence some rules exist in SonarLint that target security rules. SonarLint is developer-friendly as it provides quick-fixes and clear descriptions with small code examples. However, it only provides a small number of security rules and the rules are not easily customized.
I definitely recommend SonarLint, but also recommend supplementing it with a more security-focused tool.}{Lint}
{Develop}{Real-time}{Quick-fix}

\battlecard{Snyk Open Source}{\url{https://snyk.io/product/open-source-security-management/}}{
\label{bc:snyk_open_source}
Snyk Open Source tests for vulnerabilities in open-source dependencies. It is available in several \glspl{ide} but its web view is the most useful. Snyk Open Source provides remediation through automated pull requests to bump the dependency to the latest version.
Both GitHub and GitLab have built-in alternatives and I highly recommend using a tool like this.}{\gls{sca}}
{Build}{Seconds}{Pull request}

\battlecard{Snyk Code}{\url{https://snyk.io/product/snyk-code/}}{
\label{bc:snyk_code}
Snyk Code (formerly DeepCode.ai) claims to be a developer-first static analysis tool.
It is a plugin available for JetBrains \glspl{ide} and VisualStudio Code.
It works by uploading the code to a cloud service that runs the analysis, which are then displayed in the gls{ide}.
While they claim the scans are real-time, in reality I have found that even for very small projects they already take several seconds.
The rules cannot be customized as they are generated by machine learning based on open-source commits.
Remediation is offered in the form of code examples from these code examples on GitHub.
These are not always great examples, and sometimes they are even different from the text description.
However, the results are usually easy to understand and apply.
}{\gls{sca}}
{Develop}{Seconds}{Code examples}

\battlecard{Dependabot}{\url{https://dependabot.com/}}{
\label{bc:dependabot}
Dependabot creates pull requests to keep your dependencies secure and up-to-date. It is acquired by GitHub and is since free to use and integrated into the platform.
}{\gls{sca}}{Build}{Seconds}
{Pull request}

\battlecard{GitLab Dependency Scanning}{\url{https://gitlab.com/gitlab-org/security-products/dependency-scanning}}{
\label{bc:gitlab}
GitLab's integrated dependency scanner supports many languages and package managers. It provides remediation through automated merge requests, GitLab's term for pull requests.
}{\gls{sca}}{Build}{Seconds}{Merge request}

\battlecard{FindBugs}{\url{http://findbugs.sourceforge.net/}}{
\label{bc:findbugs}
FindBugs is a static analysis tool that looks for bugs in Java code. It has not been updated since 2017 and its spiritual successor is SpotBugs.
Its \gls{ide} plugin is not compatible with newer versions of IntelliJ.
To customize the rules, \glspl{api} must be used.
A popular plugin exists, Find Sec Bugs, that is still updated.
This plugin customizes the rule set and adds over 100 security bugs.}{\gls{sast}}
{Test}{Minutes}{Description}

\battlecard{SpotBugs}{\url{http://findbugs.sourceforge.net/}}
{
\label{bc:SpotBugs}
SpotBugs is a community supported successor of FindBugs.
It is free to use and can find up to 400 bug patterns in Java code.
Its IDE plugin is still compatible with the newest version of IntelliJ but the Find Sec Bugs rules can not be easily added to this IDE plugin.
SpotBugs is the spiritual successor of FindBugs, carrying on from the point where it left off with support of its community.
SpotBugs' bug descriptions are very short, do not suggest any remediation but provide links to relevant Wikipedia articles. 

This lack of information and remediation to the developer has shown to result in low developer trust, as was explained in Section~\ref{sec:efp}.
Experiments with this tool showed that half of the reported issues are never even reviewed~\cite{ayewah2007using}.
SpotBugs is well researched~\cite{ayewah2007using,ayewah2010google,findbugs2008} and used in industry.
It is also used at the company of one of our trials.

Research by Ayewah et al.~\cite{ayewah2007using} showed that the tool has an \gls{efp} rate of 77\%, and that the most interesting bugs were found and fixed without SpotBugs, namely after they were revealed by static analysis scans later in the \gls{sdlc}. Ayewah et al.\ conclude, however, that the tool could have been used to discover those bugs earlier, if only it would have been used more actively by developers. This is in line with our findings indicating that a low \gls{efp} rate inhibits effectiveness. I believe that shorter scan times, better descriptions, and remediation help as available in Sensei might improve the use of SpotBugs by developers in earlier stages of development.
}{\gls{sast}}
{Test}{Minutes}{Description}

\battlecard{Semmle}{\url{https://semmle.com/}}{
\label{bc:semmle}
Semmle is a tool acquired by GitHub that also offers an \gls{ide} plugin.
It uses a reactive approach, and the default rules are focused on finding vulnerabilities, but the rules can be customized to use more local analyses and enforce code best practices.
Creating new rules is done through a custom query language, called CodeQL.
A ``Query console" is provided that has syntax highlighting and completion, two features that makes development of these queries easier.
Some example projects are available in the query console that can be used to test newly developed queries, but in my experience you have to be lucky to find relevant code.
}{\gls{sast}}
{Test}{Minutes}{None}

\battlecard{Semgrep}{\url{https://semgrep.dev/}}{
\label{bc:semgrep}
Out of all the tools reviewed in this work, Semgrep most closely resembles Sensei.
Semgrep is a fast static analysis tool commercialised as r2c (\url{https://r2c.dev/}) that uses pfff (\url{https://github.com/returntocorp/pfff/}) as a static analysis engine.
Semgrep allows easy customization of rules through a \gls{yaml} syntax that is very similar to that of Sensei.
It provides advanced features to tune rules so that they minimize the chance for \glspl{efp}.
Semgrep rules also include fixes, and use so-called metavariables to reuse parts of the original code, which seems more user-friendly than the moustache code provided by Sensei.

To develop new Semgrep rules, a web-interface called the Playground can be used.
In this interface rules can be developed and tested on any fragment of code, which makes development a smooth experience.
It also makes it easy to share examples and working rules among the community.
A large set of default and community rules are available, most of which target security issues.
No real, fleshed-out \gls{ui} is available to create rules, and the rule-writer is required to read documentation to fully understand the rule syntax.
In our research, this has shown to be a hurdle for developers who can be thrown of by learning a new syntax for this purpose.
Security professionals, on the other hand, will find that this format is already a big improvement over many other security tools.
It also took me a while to get more complex rules working, but I found great community support on the r2c slack channel.

Despite marketing material using the term ``paving the road", Semgrep is somewhat lacking as a developer tool supporting the paved path methodology, as it is mostly intended as a \gls{ci} tool.
Third party plugins are available for some \glspl{ide}, but they are not officially supported.
At the time of writing, the IntelliJ IDEA plugin neither support the newest version of IntelliJ nor the newest version of Semgrep.
}{\gls{sast}}
{Test}{Seconds}{Quick-fix}

\battlecard{Checkmarx}{\url{https://checkmarx.com/}}{
\label{bc:checkmarx}
CxSAST~\cite{cxsast} is the static analysis tool by Checkmarx that perfoms source code scans.
It has support for over 25 coding and scripting languages, including Java, C\#, and python. 
CxSAST has \gls{ide} plugins for Eclipse, Visual Studio, and IntelliJ. 
In contrast to Sensei, these plugins do not perform any local scans but instead allow uploading the source code to CxSAST.
They provide an interactive way to view the scan results by marking the relevant code in the \gls{ide} editor. 
Vulnerabilities marked in the scan results have a category but no descriptions are provided. This means that little help is provided compared to the remediation suggestions and quick-fixes of Sensei.
This way developers can learn about the vulnerability and how to fix it in an interactive way. This integration is similar to the integration between Secure Code Warrior and Fortify on Demand or Sensei.

Checkmarx claims flexible rules lead to higher accuracy, and the tool uses a very extensive Query Language (CxQL)~\cite{cxaudit} to allow the creation of rules.  
It uses regular Java syntax and is easy to understand.
There is good documentation available but no proper tool to create or test rules, this makes development of the rules notably more difficult.
It seems that the rules in CxQL can be built to ignore context and enforce secure coding guidelines in line with the paved path methodology.
It is also possible to tune CxSAST so that it uses more lightweight analyses, resulting in faster feedback.
}{\gls{sast}}{Test}{Minutes}{Guidance}

\battlecard{Tricorder}{\url{https://research.google/pubs/pub43322/}}{
\label{bc:tricorder}
Tricorder~\cite{sadowski2015tricorder} is a data-driven program analysis platform integrated into the workflow of developers at Google. Tricorder's design philosophy closely resembles that of Sensei where they put developer usability first. Custom analyzers are written in Java, C++, Python, or Go, and also require setting up a service in a docker file. 

The results of Tricorder analyzers are shown in a review tool. In this tool quick-fixes are available, but empirical observations have shown they are not used frequently, as only a 20\% ``Apply fix" rate is reported for Tricorder~\cite{sadowski2015tricorder}. It is hypothesised that developers prefer to go back to their \gls{ide} to fix the problems~\cite{sadowski2015tricorder}. 
After carefully improving their analyzers, Tricorder reached an \gls{efp} rate of around 5\%. While both the customized rules of Sensei and the customized analyzers used by Tricorder appear to be effective solutions for preventing \glspl{efp}, quick-fixes are more practical in the IDE than during the test or review stage, as is evident from the low ``Apply fix" rate for Tricorder. 
}{\gls{sast}}{Test}{Minutes}{Quick-fix}

\battlecard{Shipshape}{\url{https://github.com/google/shipshape}}{
\label{bc:shipshape}
Shipshape is the open-source version of Tricorder (battlecard~\ref{bc:tricorder}).
}{\gls{sast}}{Test}{Minutes}{Quick-fix}

\battlecard{Fortify Static Code Analyzer}{\url{https://www.microfocus.com/en-us/cyberres/application-security/static-code-analyzer}}{
\label{bc:fortify-sca}
Micro Focus Fortify is an ecosystem that embeds application security testing into all stages of the development tool chain. 

As the name suggests, \gls{fsca}~\cite{fsca} performs static code analysis on the source code. It can be built in \gls{cicd} tools and has support for 25 programming languages including Java and C\#. Scanning takes several minutes and the results can be shown in a web interface or in integrations with many bug tracking systems, ticketing systems, and code repositories. Fortify recommends using their rule sets that cover over 1000 vulnerability categories and more than one million \glspl{api}. Creating new rules can be done in their custom \gls{xml} format in any text editor~\cite{fsca-curstom-rules}. Doing so requires reading extensive documentation and learning the proper syntax. They do not provide a rule editor, instead the rule writer can use any preferred text editor. 

\gls{fsca} provides detailed descriptions of vulnerabilities, which focus on explaining the vulnerabilities in detail, in part by providing examples of insecure code.
}{\gls{sast}}{Test}{Minutes}{Description}

\battlecard{Fortify on Demand}{\url{https://www.microfocus.com/en-us/cyberres/application-security/fortify-on-demand}}{
\label{bc:fortify_on_demand}
\Gls{fod}~\cite{fod} provides similar features to FSCA (battlecard~\ref{bc:fortify-sca}) but through a web portal, Micro Focus calls this ``Application Security Testing as a Service".
It provides the same feedback as \gls{fsca}, but in a second tab, also provides a description and code examples to resolve the vulnerability.
Both tools also provide links to reference material and to recommended solutions, but on top, \gls{fod} provides links to Secure Code Warrior to provide training on a specific vulnerability. 

An \gls{fod} plugin is available for Eclipse, Visual Studio, and IntelliJ.
It allows the developer to request static assessments from \gls{fod} by uploading the code and downloading the results.
}{\gls{sast}}{Test}{Minutes}{Description}

\battlecard{Fortify Security Assistant}{\url{https://marketplace.microfocus.com/fortify/category/plugins}}{
\label{bc:fsa}
\Gls{fsa}~\cite{fsa} is a plugin currently available for Eclipse and Visual Studio. It allows security scans similar to that of \gls{fsca} (battlecard~\ref{bc:fortify-sca}) and \gls{fod} (battlecard~\ref{bc:fortify_on_demand}), but does so in the \gls{ide}. 
The rule set is tuned such that the longest analyses are disabled by default.
The scan can take several minutes during which the developer cannot make any code changes. This is still quite long compared to the real-time results of Sensei and might inhibit developers from requesting scans frequently during development.
}{\gls{sast}}{Test}{Minutes}{Description}


\battlecard{Veracode Static Analysis}{\url{https://www.veracode.com/products/binary-static-analysis-sast}}{
\label{bc:veracode-sa}
\Gls{vsa} is a \gls{saas} platform that allows the developer to upload their code to be analyzed. .
The tool perform static analysis scans on compiled bytecode of web applications in 23 programming languages.
Because it does not need access to the source code it can also analyse frameworks and libraries used in the project. 
The downside to this approach is that sufficient code needs to be finished and a successful build is required.

Veracode focuses heavily on detecting vulnerabilities but also guides remediation. 
To that extent, they provide detailed instructions and videos.
There is even the possibility to schedule a one-on-one conference call with a consultation expert. 

The company claims most scans finish in under an hour. This means the feedback cycle is rather long compared to the other tools. Since the scans are performed on binaries, they are not able to provide quick-fixes as Sensei does, which is unfortunate for a solution otherwise very focused on remediation.
}{\gls{sast}}{Test}{Hour}{Descriptions}

\battlecard{Veracode Greenlight}{\url{https://help.veracode.com/r/c_master_greenlight}}{
\label{bc:veracode-gl}
\Gls{vg} is an \gls{ide} plugin that performs lightweight versions of the analyses performed by \gls{vsa} (battlecard~\ref{bc:veracode-sa}).
In my opinion, \gls{vg} is not suited as a developer tool.
The lack of rule customization, absence of quick-fixes, and the fact that it analyzes bytecode are all big hurdles for it to be well-integrated in the developer workflow.
}{\gls{sast}}{Test}{Minutes}{Descriptions}

\battlecard{Ruleguard}{\url{https://go-ruleguard.github.io/}}{
\label{bc:ruleguard}
Ruleguard is an analysis for the Go programming language that runs dynamically loaded rules written in Go.
Its rules are not restricted to the \gls{ast},as it can even match comments.
It is not integrated in the \gls{ide} but does provide quick-fixes.
They can be invoked with the `-fix` argument when running Ruleguard in the terminal.
It has been shown that quick-fixes outside the \gls{ide} are not frequently used by developers~\cite{sadowski2015tricorder}.
The lack of IDE support, and the fact that rule customization is done through a programming language makes this tool less than ideal for use in the paved path methodology.
}{Linter}{Test}{Seconds}{Descriptions}

\battlecard{OpenRewrite}{\url{https://github.com/openrewrite/rewrite}}{
\label{bc:openrewrite}
OpenRewrite focuses on code refactoring, and the focus is mostly on quality.
Its rules always include a ``fix" part.
Rules are defined in a \gls{yaml} format, but require only define parameters for one of the basic building block transformations, such as ``Change method name", ``Remove annotation".
This closely resembles the original approach taken in the Sensei rule editor, where separate models were created for each such scenario.
This quickly caused the amount of models to be unnecessary large and difficult to distinguish from one another.
The amount of building blocks supported by OpenRewrite is very limited, however.
There is no ``Change method argument" model available, which would be required to detect use of the \gls{des} algorithm as is the running example in this work.
The documentation describes how a new model can be developed using their \gls{api}.
}{Refactor}{Develop}{Seconds}{Fix}

\battlecard{OWASP ASIDE}{\url{https://wiki.owasp.org/index.php/OWASP\_ASIDE\_Project}}
{
\label{bc:ASIDE}
The OWASP ASIDE/ESIDE~\cite{aside} project consist of two branches, the ASIDE branch that focuses on detecting software vulnerabilities and helping developer write secure code, and the ESIDE branch that focuses on helping students in acquiring secure programming knowledge and practices.

ASIDE stands for Application Security \gls{ide} (another source claims it is an abbreviation for Assured Software \gls{ide}). It performs fast scans of the code in Eclipse, but unlike Sensei the scans need to be started manually.
Besides detecting vulnerabilities they also provide quick-fixes for some issues. 
The quick-fixes require the developers to choose from a list of options, which could overwhelm them.
In previous research a large number of false positives were detected~\cite{xie2011aside}, however, most of these are what is considered protection for future use in this work.
They are cases where best practices should be applied even if their violation is not yet exploitable at this point in development.
ASIDE also marks variables in the code that are tainted, this could be compared to Sensei's concept of untrusted input.
Untrusted input in Sensei is not currently marked to avoid unnecessary clutter. 

The goal of ESIDE~\cite{eside,whitney2018embedding} is to provide information and training at all times during the education. Its rules can not be configured and the tool does not provide quickfixes. However they provide explanation in external web pages linked from Eclipse. Their information is similar to our full coding guidelines where information on \glspl{api} and a correct code example is provided.

The project is no longer supported and many of the links on the website are dead.
}{\gls{sast}}{Develop}{Seconds}{Fix (sometimes)}

\battlecard{SecureAssist}{\url{https://community.synopsys.com/s/article/SecureAssist-Overview}}
{
\label{bc:SecureAssist}
SecureAssist~\cite{secureassist} is an IDE plugin targeting the discovery of security bugs in code.
It is available for eclipse, intelliJ, VisualStudio, RAD, and Spring Tool Suite~\cite{sastinide}.
Its scans are not performed in the \gls{ide} but on the enterprise portal.
The results are sent back to the \gls{ide} once completed.
This allows scanning without preventing the developer from continuing his work. Remediation is provided in the form of descriptions that explain the attack and provide some code examples but the tool does not provide quick-fixes~\cite{secureassistide}. 

Rule packs are distributed as \gls{jar} files and the tool provides a Rulepack Configurator similar to Sensei's cookbook Manager.
The rules themselves are created in an \gls{xml} format.
No user interface is provided, and writing the rules requires going through long documentation.
}{\gls{sast}}{Test}{Minutes}{Description}

\battlecard{GoKart}{\url{https://github.com/praetorian-inc/gokart}}
{
\label{bc:gokart}
GoKart is a static analysis tool for Go.
It uses specialized techniques for more accurate taint tracking in Go.
The analyzers can be easily extended using a \gls{yaml} format.
However, there is no \gls{ide} integration and the tool does not offer any form of remediation guidance, so it is not the best suited to give to the developer.
}{\gls{sast}}{Test}{Minutes}{None}

%\smallbattlecard{Pluralsight}{\url{https://www.pluralsight.com/}}{
%\label{bc:pluralsight}
%Pluralsight is a website that hosts training and courses for developers, among which some security courses.
%One of the features of the site is called Iris.
%This feature uses machine learning, statistics, and \gls{irt} to measure the skill of a developer and recommend a skill development journey.
%This does not tailor courses to the individual, but recommends the most appropriate course for the user.
%}{Training}{Plan}