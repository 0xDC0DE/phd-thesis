\chapter{Security battlecards}
\label{app:battlecards}

\battlecard{SonarLint by SonarSource}{\url{https://www.sonarlint.org/}}{
\label{bc:sonarlint}
SonarLint is a free IDE plugin that focuses on code quality. As explained in this work code quality and code security are often related and hence some rules exist in SonarLint that target security rules. SonarLint is developer-friendly as it provides quick-fixes and clear descriptions with small code examples. However, it only provides a small number of security rules and the rules are not easily customized.}{Lint}
{Develop}{Real-time}{Quick-fix}

\battlecard{Snyk Open Source}{\url{https://snyk.io/}}{
\label{bc:snyk_open_source}
Snyk Open Source tests for vulnerabilities in open-source dependencies. It is available in several IDEs but its web view is the most useful. Snyk Open Source provides remediation through automated pull requests to bump the dependency to the latest version.}{SCA}
{Build}{Seconds}{Pull request}

\battlecard{Dependabot}{\url{https://dependabot.com/}}{
\label{bc:dependabot}
Dependabot creates pull requests to keep your dependencies secure and up-to-date. It is acquired by GitHub and is since free to use and integrated into the platform.
}{SCA}{Build}{Seconds}
{Pull request}

\battlecard{GitLab Dependency Scanning}{\url{https://gitlab.com/gitlab-org/security-products/dependency-scanning}}{
\label{bc:gitlab}
GitLab's integrated dependency scanner supports many languages and package managers. It provides remediation through automated merge requests, GitLab's term for pull requests.
}{SCA}{Build}{Seconds}{Merge request}

\battlecard{FindBugs}{\url{http://findbugs.sourceforge.net/}}{
\label{bc:findbugs}
FindBugs is a static analysis tool that looks for bugs in Java code. It has not been updated since 2017 and its spiritual successor is SpotBugs.
Its IDE plugin is not compatible with newer versions of IntelliJ.
To customize the rules, APIs must be used.
A popular plugin exists, Find Sec Bugs, that is still updated.
This plugin customizes the rule set and adds over 100 security bugs.}{SAST}
{Test}{Minutes}{Description}

\battlecard{SpotBugs}{\url{http://findbugs.sourceforge.net/}}
{
\label{bc:SpotBugs}
SpotBugs is a community supported successor of FindBugs.
It is free to use and can find up to 400 bug patterns in Java code.
Its IDE plugin is still compatible with the newest version of IntelliJ but the Find Sec Bugs rules can not be easily added to this IDE plugin.
SpotBugs is the spiritual successor of FindBugs, carrying on from the point where it left off with support of its community.
SpotBugs' bug descriptions are very short, do not suggest any remediation but provide links to relevant Wikipedia articles. 

This lack of information and remediation to the developer has shown to result in low developer trust, as was explained in Section~\ref{sec:efp}.
Experiments with this tool showed that half of the reported issues are never even reviewed~\cite{ayewah2007using}.
SpotBugs is well researched~\cite{ayewah2007using,ayewah2010google,findbugs2008} and used in industry.
It is also used at the company of one of our trials.

Research by Ayewah et al.~\cite{ayewah2007using} showed that the tool has an \gls{efp} rate of 77\%, and that the most interesting bugs were found and fixed without SpotBugs, namely after they were revealed by static analysis scans later in the SDLC. Ayewah et al.\ conclude, however, that the tool could have been used to discover those bugs earlier, if only it would have been used more actively by developers. This is in line with our findings indicating that a low EFP rate inhibits effectiveness. I believe that shorter scan times, better descriptions, and remediation help as available in Sensei might improve the use of SpotBugs by developers in earlier stages of development.
}{SAST}
{Test}{Minutes}{Description}

\battlecard{Semmle}{\url{https://semmle.com/}}{
\label{bc:semmle}
Semmle is a tool acquired by GitHub that also offers an \gls{ide} plugin.
It uses a reactive approach, and the default rules are focused on finding vulnerabilities, but the rules can be customized to use more local analyses and enforce code best practices.
Creating new rules is done through a custom query language, called CodeQL.
A ``Query console" is provided that has syntax highlighting and completion, two features that makes development of these queries easier.
Some example projects are available in the query console that can be used to test newly developed queries, but in my experience you have to be lucky to find relevant code.
}{SAST}
{Test}{Minutes}{None}

\battlecard{Semgrep}{\url{https://semgrep.dev/}}{
\label{bc:semgrep}
Out of all the tools reviewed in this work, Semgrep most closely resembles Sensei.
Semgrep is a fast static analysis tool commercialised as r2c (\url{https://r2c.dev/}) that uses pfff (\url{https://github.com/returntocorp/pfff/}) as a static analysis engine.
Semgrep allows easy customization of rules through a \gls{yaml} syntax that is very similar to that of Sensei.
It provides advanced features to tune rules so that they minimize the chance for EFPs.
Semgrep rules also include fixes, and use so-called metavariables to reuse parts of the original code, which seems more user-friendly than the moustache code provided by Sensei.


To develop new Semgrep rules, a web-interface called the Playground can be used.
In this interface rules can be developed and tested on any fragment of code, which makes development a smooth experience.
It also makes it easy to share examples and working rules among the community.
A large set of default and community rules are available, most of which target security issues.
No real, fleshed-out \gls{ui} is available to create rules, and the rule-writer is required to read documentation to fully understand the rule syntax.
In our research, this has shown to be a hurdle for developers who can be thrown of by learning a new syntax for this purpose.
Security professionals, on the other hand, will find that this format is already a big improvement over many other security tools.
It also took me a while to get more complex rules working, but I found great community support on the r2c slack channel.

Despite marketing material using the term ``paving the road", Semgrep is somewhat lacking as a developer tool supporting the paved path methodology, as it is mostly intended as a \gls{ci} tool.
Third party plugins are available for some \glspl{ide}, but they are not officially supported.
At the time of writing, the IntelliJ IDEA plugin neither support the newest version of IntelliJ nor the newest version of Semgrep.
}{SAST}
{Test}{Seconds}{Quick-fix}

\battlecard{Checkmarx}{\url{https://checkmarx.com/}}{
\label{bc:checkmarx}
CxSAST~\cite{cxsast} is the static analysis tool by Checkmarx that perfoms source code scans.
It has support for over 25 coding and scripting languages, including Java, C\#, and python. 
CxSAST has IDE plugins for Eclipse, Visual Studio, and IntelliJ. 
In contrast to Sensei, these plugins do not perform any local scans but instead allow uploading the source code to CxSAST.
They provide an interactive way to view the scan results by marking the relevant code in the IDE editor. 
Vulnerabilities marked in the scan results have a category but no descriptions are provided. This means that little help is provided compared to the remediation suggestions and quick-fixes of Sensei.
This way developers can learn about the vulnerability and how to fix it in an interactive way. This integration is similar to the integration between Secure Code Warrior and Fortify on Demand or Sensei.

Checkmarx claims flexible rules lead to higher accuracy, and the tool uses a very extensive Query Language (CxQL)~\cite{cxaudit} to allow the creation of rules.  
It uses regular Java syntax and is easy to understand.
There is good documentation available but no proper tool to create or test rules, this makes development of the rules notably more difficult.
It seems that the rules in CxQL can be built to ignore context and enforce secure coding guidelines in line with the paved path methodology.
It is also possible to tune CxSAST so that it uses more lightweight analyses, resulting in faster feedback.
}{SAST}{Test}{Minutes}{Guidance}

\battlecard{Tricorder}{\url{https://research.google/pubs/pub43322/}}{
\label{bc:tricorder}
Tricorder~\cite{sadowski2015tricorder} is a data-driven program analysis platform integrated into the workflow of developers at Google. Tricorder's design philosophy closely resembles that of Sensei where they put developer usability first. Custom analyzers are written in Java, C++, Python, or Go, and also require setting up a service in a docker file. 

The results of Tricorder analyzers are shown in a review tool. In this tool quick-fixes are available, but empirical observations have shown they are not used frequently, as only a 20\% ``Apply fix" rate is reported for Tricorder~\cite{sadowski2015tricorder}. It is hypothesised that developers prefer to go back to their IDE to fix the problems~\cite{sadowski2015tricorder}. 
After carefully improving their analyzers, Tricorder reached an EFP rate of around 5\%. While both the customized rules of Sensei and the customized analyzers used by Tricorder appear to be effective solutions for preventing EFPs, quick-fixes are more practical in the IDE than during the test or review stage, as is evident from the low ``Apply fix" rate for Tricorder. 
}{SAST}{Test}{Minutes}{Quick-fix}

\battlecard{Shipshape}{\url{https://github.com/google/shipshape}}{
\label{bc:shipshape}
Shipshape is the open-source version of Tricorder (battlecard~\ref{bc:tricorder}).
}{SAST}{Test}{Minutes}{Quick-fix}

\battlecard{Fortify Static Code Analyzer}{\url{https://www.microfocus.com/en-us/cyberres/application-security/static-code-analyzer}}{
\label{bc:fortify-sca}
Micro Focus Fortify is an ecosystem that embeds application security testing into all stages of the development tool chain. 

As the name suggests, \gls{fsca}~\cite{fsca} performs static code analysis on the source code. It can be built in CI/CD tools and has support for 25 programming languages including Java and C\#. Scanning takes several minutes and the results can be shown in a web interface or in integrations with many bug tracking systems, ticketing systems, and code repositories. Fortify recommends using their rule sets that cover over 1000 vulnerability categories and more than one million APIs. Creating new rules can be done in their custom XML format in any text editor~\cite{fsca-curstom-rules}. Doing so requires reading extensive documentation and learning the proper syntax. They do not provide a rule editor, instead the rule writer can use any preferred text editor. 

FSCA provides detailed descriptions of vulnerabilities, which focus on explaining the vulnerabilities in detail, in part by providing examples of insecure code.
}{SAST}{Test}{Minutes}{Description}

\battlecard{Fortify on Demand}{\url{https://www.microfocus.com/en-us/cyberres/application-security/fortify-on-demand}}{
\label{bc:fortify_on_demand}
\Gls{fod}~\cite{fod} provides similar features to FSCA (battlecard~\ref{bc:fortify}) but through a web portal, Micro Focus calls this ``Application Security Testing as a Service".
It provides the same feedback as FSCA, but in a second tab, also provides a description and code examples to resolve the vulnerability.
Both tools also provide links to reference material and to recommended solutions, but on top, FOD provides links to Secure Code Warrior to provide training on a specific vulnerability. 

An FOD plugin is available for Eclipse, Visual Studio, and IntelliJ.
It allows the developer to request static assessments from FOD by uploading the code and downloading the results.
}{SAST}{Test}{Minutes}{Description}

\battlecard{Fortify Security Assistant}{\url{https://marketplace.microfocus.com/fortify/category/plugins}}{
\label{bc:fsa}
\Gls{fsa}~\cite{fsa} is a plugin currently available for Eclipse and Visual Studio. It allows security scans similar to that of FSCA (battlecard~\ref{bc:fortify}) and FOD (battlecard~\ref{bc:fortify_on_demand}), but does so in the IDE. 
The rule set is tuned such that the longest analyses are disabled by default.
The scan can take several minutes during which the developer cannot make any code changes. This is still quite long compared to the real-time results of Sensei and might inhibit developers from requesting scans frequently during development.
}{SAST}{Test}{Minutes}{Description}


\battlecard{Veracode Static Analysis}{\url{https://www.veracode.com/products/binary-static-analysis-sast}}{
\label{bc:veracode-sa}
\Gls{vsa} is a SaaS platform that allows the developer to upload their code to be analyzed. .
The tool perform static analysis scans on compiled bytecode of web applications in 23 programming languages.
Because it does not need access to the source code it can also analyse frameworks and libraries used in the project. 
The downside to this approach is that sufficient code needs to be finished and a successful build is required.

Veracode focuses heavily on detecting vulnerabilities but also guides remediation. 
To that extent, they provide detailed instructions and videos.
There is even the possibility to schedule a one-on-one conference call with a consultation expert. 

The company claims most scans finish in under an hour. This means the feedback cycle is rather long compared to the other tools. Since the scans are performed on binaries, they are not able to provide quick-fixes as Sensei does, which is unfortunate for a solution otherwise very focused on remediation.
}{SAST}{Test}{Hour}{Descriptions}

\battlecard{Veracode Greenlight}{\url{https://help.veracode.com/r/c_master_greenlight}}{
\label{bc:veracode-gl}
\Gls{vg} is an \gls{ide} plugin that performs lightweight versions of the analyses performed by \gls{vsa} (battlecard~\ref{bc:veracode}).
In my opinion, \gls{vg} is not suited as a developer tool.
The lack of rule customization, absence of quick-fixes, and the fact that it analyzes bytecode are all big hurdles for it to be well-integrated in the developer workflow.
}{SAST}{Test}{Minutes}{Descriptions}