\chapter{Security in software development}
\label{ch:related}

context
need

In this chapter an objective overview is provided of general security practices and tools, discussed in order of their appearance in the \gls{sdlc}.
I have also added an overview of recommended tools to Appendix~\ref{app:battlecards} containing a brief summary and some personal opinions.

\summarybox{
findings and conclusion
}

\include{04-tools/07-related/sections/00-plan}
\include{04-tools/07-related/sections/01-develop}
\include{04-tools/07-related/sections/02-build}
\include{04-tools/07-related/sections/03-test}
\include{04-tools/07-related/sections/04-release}

\section*{List of stuff to look at}
Check these sources: 
https://owasp.org/www-community/Source\_Code\_Analysis\_Tools
https://owasp.org/www-community/Vulnerability\_Scanning\_Tools
https://kompar.tools/
https://securecodewarrior.atlassian.net/wiki/spaces/CP/pages/993329838/Why+wouldn+t+you+use+X+instead
https://securecodewarrior.atlassian.net/wiki/spaces/CP/pages/1103265877/Sensei+Competitive+Space

Open Policy Agent (OPA)!!
github copilot
amazon guru
privacy (and laws): consumers claiming rights(Brian Chess gurus)
\paragraph{Tricorder}
\subsection{WhiteSource Cure}
WhiteSource cure

WhiteSource Cure looks interesting at a glance. But if you dig into it a bit, I think they’ve taken a few major short-cuts and odd decisions.
They decide to not parameterize all inputs to a SQL query. This is bad because it shows to developers that it’s OK to not always parameterize all inputs.
There’s some interesting comments in some of the fixes. If a setFeature call fails on a DocumentBuilderFactory, they are suggesting you should check for possible attack. That’s kind of FUD. That suggests no attack whatsoever.
They are not detecting super obvious SQL injection issues right next to other fixes they are providing.
Some of their suggestions handle things in a way that’s not exactly how I’d do it. For instance, their fix for path traversal needs 2 more changes by a developer to work without causing major issues. And it makes assumptions about the correct design that I don’t think are valid. You’re thus not fixing the issue at its root.
https://securecodewarrior.slack.com/archives/C92HYQNVA/p1627890321009700
\paragraph{Aside}
\paragraph{SpotBugs}
\paragraph{SecureAssist}
\paragraph{Veracode}
\paragraph{Snyk}
\paragraph{ReshiftSecurity}
TODO: %https://www.reshiftsecurity.com/product/ 
- based on Spotbugs and (I think) the SpotBugs security plugin
- does not play nice with spotbugs (removes ability to configure spotbugs preferences ) so I think they may not have amended Spotbugs code enough to make it an independent plugin
- autofix functionality doesn't appear to be present in the IDE, I think that is through a CI integration
- don't think you can create your own rules easily
- not sure how good it is at identifying security issues, it did not pick up an SQL injection in my sample project
```
            Statement stm = dbConnection.createStatement();
            ResultSet res = stm.executeQuery(
                    "SELECT description from todos where status=" + status);
```

%%https://www.producthunt.com/posts/reshift-security
\paragraph{Semmle}
  %https://www.theregister.co.uk/2020/05/06/github\_releases\_codescanning\_tool/
  Semmle is cool stuff. But:
It’s not a developer-focused tool per say. It’s complex, and requires appsec to write rules
It’s not in your IDE
It is very focused on “Is this exploitable?“, which means it’s not useful for enforcing code best practices
It doesn’t give you quick-fixes
It doesn’t give you contextual education
Hence, it doesn’t close the loop to help prevent them from reoccurring

\paragraph{CodeQL} - former Semmle?

\paragraph{Checkmarx}

\paragraph{CodeInspector}
%%https://www.code-inspector.com/
\paragraph{SemGrep}
%https://r2c.dev/blog/2020/be-careful-what-you-request-for-django-method/ 
%https://r2c.dev/blog/2020/hardcoded-secrets-unverified-tokens-and-other-common-jwt-mistakes/
\paragraph{Pluralsight}
%https://help.pluralsight.com/help/vs-code-extension

\paragraph{RuleGuard}

\paragraph{Explore.dev}
%https://explore.dev/

\paragraph{Deepcode}
(Matias:)
deepcode.ai
Deepcode is a University project spin off (Spun of in 2016). It’s focus was on quality code, not security in specific.
Focus on:
* Accuracy
* Speed
* For developers
When demoing, main focus went to the IDE plugin (Can also work in Pull request and in CD/CD). Demo was very slick. it shows errors and warnings, and it shows other places in the code where a developer made that change before, essentially they went through the entire history of checkins and make rules out of that (not really rules, it is in their AI/ML module). So it is not only finding, it does have a focus on real fixes, potentially in line with the code base, stuff that can actually work.
AI/ML component is very interesting. AI/ML instead of rules based is very interesting. If this works, if they can pull that off, it is a good approach to get rid of manual effort and still be custom to the code (but that is not the focus, so this is not happening right now). It diminishes the number of researchers they have to have on staff to create rules. It reduces the time to value for customers using the solution.
Compared to Semmle: Seems to have a lot of similarities. Started as a tool focused on quality, not specifically security. Was a university project first which was incubated, so not really a focus on making this work at scale. (Great for a demo, great in theory, great on a small code base, but what about the real world). However, from what they have shown, it looks better/easier/slicker/more mature than Semmle.
If the demo works in practice on large codebases, then I think it will be a significant challenger for the established SAST solutions.
I think there is an opportunity for SCW to be in there and educate the developer. The examples in the demo were simplistic (hardcoded passwords) so there was no need for training, but I can see a role for the SCW training platform with what I’ve seen
Sensei, that becomes more interesting, but there are advantages and disadvantages. Sensei is still real-time, Snyk Code is when pressing a button, and in a different window. Sensei has a quick fix, Snyk does not have one. Sensei is more tailored to the code, Snyk is not. But then there are undeniable advantages of their approach. The ML/AI instead of rules should be better in terms of configuration, rules support, … if and only if this AI/ML thing work. And that AI/ML thing may show quicker value than Sensei, as the upfront work is less on Snyk code. Sensei feels more enterprise than Snyk code tbh, I don’t see them doing what we do at NetSuite, that AI/ML is too free form and can propose whatever.

(Brysen:)
I just watched the demo videos on their youtube channel.
Sending your code to their servers is an annoying thing.
The way they provide a “fix” is done by showing you examples of open source repos where this issue should have been fixed, but in their example it doesn’t even show the same code as the found vulnerability so effectively the user still needs to plow through the suggested changes and determine if they are right in which they still need a good too strong security knowledge.

Specifically to Sensei, one thing we have to copy is showing an example. So the suggestion they make is together with an example of another place in the code where this is also the case (or where that same change was executed). That looked really cool. I think in Sensei that would work even better, because we should do that in the code base itself, and not on some random other open source project... My 2 cents

\subsubsection{Fortify}
Micro Focus Fortify is an ecosystem that embeds application security testing into all stages of the development tool chain. Some of the most comparable tools to Sensei in their ecosystem are Fortify Static Code Analyzer (FSCA), Fortify on Demand (FOD), and Fortify Security Assistant (FSA). 

As the name suggests, FSCA~\cite{fsca} performs static code analysis on the source code. It can be built in CI/CD tools and has support for 25 programming languages including Java and C\#. Scanning takes several minutes and the results can be shown in a web interface or in integrations with many bug tracking systems, ticketing systems, and code repositories. Fortify recommends using their rule sets that cover over 1000 vulnerability categories and more than one million APIs. Creating new rules can be done in their custom XML format in any text editor~\cite{fsca-curstom-rules}. Doing so requires reading extensive documentation and learning the proper syntax. They do not provide a rule editor, instead the rule writer can use any preferred text editor. FOD~\cite{fod} provides similar features to FSCA but through a web portal, Micro Focus calls this Application Security as a Service. 

FSA~\cite{fsa} is a plugin for the IDE, currently available for Eclipse and Visual Studio. It allows security scans in the IDE, where the rule set is tuned such that the longest analyses are disabled by default. The scan can take several minutes during which the developer cannot make any code changes. This is still quite long compared to the real-time results of Sensei and might inhibit developers from requesting scans frequently during development. 

%\changed{As already discussed in Section \ref{sec:evaluation} this demonstrates the trade-off for early detection: a more light-weight version of the analyses is performed in the IDE to guarantee the developers' usability, which means that not all potential issues can be detected at this stage.}

Besides the FSA, Fortify offers two more IDE plugins. The FOD plugin is available for Eclipse, Visual Studio, and IntelliJ. It allows the developer to request static assessments from FOD and download the results. A similar plugin is available for FSCA on all three IDEs. 

FOD allows scan results to be evaluated against custom security policies in order to hide reports of certain vulnerability types. During installation of the FSA in the IDE, a link to a remote Rulepack Update Server is required, this allows the tool to download the necessary rule information to perform scans. It is also possible to use a local copy of the rules when no network connection is available. The FSA also allows enabling and disabling each individual rule in the UI. 

Each tool provides detailed descriptions on vulnerabilities, which focus on explaining the vulnerabilities in detail, in part by providing examples of insecure code. In a second tab, FOD provides a description and code examples to resolve the vulnerability. All tools provide links to reference material and to recommended solutions. FOD also provides links to Secure Code Warrior to provide training on a specific vulnerability. The information provided is very similar to the different descriptions of Sensei, but the focus is more on explaining the vulnerability first instead of the solution.

Both FSCA and FOD provide a management dashboard in which the security status (failed or passed security policy) of multiple applications can be seen. The dashboard of FOD provides more detailed information where it is possible to track the amount of issues over time for each severity. It also provides an insight in the vulnerability categories of most prevalent issues. FOD can track the amount of newly introduced problems in each scan. This makes it possible to evaluate the developers' skills over time, on top of tracking the application state. However, in contrast to Sensei, no clear distinction is made between problems detected by new rules and problems detected in newly developed code.

\subsubsection{Tricorder}
Tricorder~\cite{sadowski2015tricorder}, which has an open-source version Shipshape~\cite{shipshape}, is a data-driven program analysis platform integrated into the workflow of developers at Google. Tricorder's design philosophy closely resembles that of Sensei where they put developer usability first. Like Sensei, Tricorder allows developers to share their knowledge by enriching the set of available analyses. However, instead of an easy rule editor, analyzers in tricorder may be written in any programming language. The best support is available for C++, Java, Python, and Go. Analyzers can analyze any programming language. Analyzers are encouraged to provide fixes with their analysis results to improve developer usability.

In contrast with Sensei, the results of Tricorder analyzers are shown in a review tool. In this tool the reviewer can choose from several options: Not useful, Please fix, and Apply fix. The last option will directly apply the fix suggested by the analyzer in the review tool. However, empirical observations have shown that few Apply fix clicks occur. The authors hypothesize that many developers choose to fix the code in their own editor rather than use the code review tool for this purpose~\cite{sadowski2015tricorder}. This indicates that the Sensei quickfixes are more usable, since they are applied in the IDE. 

Tricorder analyzers are deployed company wide if they meet certain criteria regarding their output. They should be easy to understand, result in few false positives, the markings should have potential for significant impact, and they should occur with small but noticeable frequency. The reasoning behind the last criterion is that there is no point in detecting problems that never occur. Conversely, if a warning occurs too frequently, it is likely that it is not really causing any problems. In order to guarantee the usability of the tool, all interactions with analyzers are monitored, and if their usefulness measured against the aforementioned criteria drop below certain thresholds the analyzers are disabled and the analyzer writer is notified such that they are able to improve the performance. While the effective false positive rate is closely monitored, Tricorder, unlike Sensei, does not apply these restrictions on a project basis, but instead all analyzers are used company-wide. In Section \ref{sec:usability} we compared the EFP rates for Tricorder and Sensei. Whereas only a 20\% "Apply fix" rate is reported for Tricorder~\cite{sadowski2015tricorder},  with Sensei 98.2\% of code markings were resolved by the developer. Of these 75.3\% were fixed using the provided quick fixes in the IDE, and only 1.8\% of code markings were ignored by Sensei users, which is a low EFP rate. After carefully improving their analyzers, Tricorder reached an EFP rate of around 5\%. While both the customized rules of Sensei and the customized analyzers used by Tricorder appear to be effective solutions for preventing EFPs, quickfixes are more practical in the IDE than during the review stage, as is evident from the low "Apply fix" rate for Tricorder. 

\subsubsection{SpotBugs}
SpotBugs~\cite{spotbugs} (formerly FindBugs~\cite{findbugs}) is a light-weight open-source analysis tool capable of finding a wide range of software bugs, including a number of security bugs~\cite{spotbugsdescriptions}. SpotBugs' bug descriptions are very short, do not suggest any remediation but provide links to relevant Wikipedia articles. This lack of information and remediation to the developer has shown to result in low developer trust, as was explained in Section~\ref{sec:usability}. Over half of the reported issues are never even reviewed.

SpotBugs allows the creation of third party "detectors", so additional security bugs can be included. These have to be implemented through an API~\cite{spotbugsapi} and compiled into a SpotBugs plugin. FindSecBugs~\cite{findsecbugs} is a popular security plugin for SpotBugs. While the creation of additional detectors is not as convenient as with Sensei, the distribution through plugins does seem to be an effective way to encourage their creation.

SpotBugs is well researched~\cite{ayewah2007using,ayewah2010google,findbugs2008} and used in industry. Despite its IDE integration, it is mostly used to scan after development due to their long scan times, which can take up to 20 minutes. In practice the tool is integrated in later parts of the SDLC and scan results of the code are often available a day or two after it has been committed to the version control repository~\cite{ayewah2010google}. 

SpotBugs provides support for so-called filter files. These files allow to manage the rules. They are used to configure the bug reports, including or excluding bugs on particular classes and methods. 

Research by Ayewah et al.~\cite{ayewah2007using} showed that the tool has an EFP rate of 77\%, and that the most interesting bugs were found and fixed without SpotBugs, namely after they were revealed by static analysis scans later in the SDLC. Ayewah et al.\ conclude, however, that the tool could have been used to discover those bugs earlier, if only it would have been used more actively by developers.  This is in line with our earlier observation that low EFP rate inhibits effectiveness. We believe that shorter scan times, better descriptions, and remediation help as available in Sensei might improve the use of SpotBugs by developers in earlier stages of development.

\subsubsection{SecureAssist}
SecureAssist~\cite{secureassist} is an IDE plugin targeting the discovery of security bugs in code. It is available for eclipse, intelliJ, VisualStudio, RAD, and Spring Tool Suite~\cite{sastinide}. Its scans are not in the IDE but on the enterprise portal. The results are sent back to the IDE once completed. This allows scanning without preventing the developer from continuing his work, which contrasts with the Fortify Security Assistant, that prevents developers from changing the code during a scan. Remediation is provided in the form of descriptions that explain the attack and provide some code examples but the tool does not provide quick fixes~\cite{secureassistide}. 

Rule packs can be added and created in their rule pack configurator. Rules are written in XML format instead of YAML but the syntax is user friendly and easily readable~\cite{secureassistruletutorial}. In Listing~\ref{lst:SAexample} an example rule for the SecureAssist plugin is shown to discover uses of the insecure DES cryptographic algorithm, as a comparison the same rule for the Sensei plugin is shown in Listing~\ref{lst:SAexample2}. SecureAssist's rule syntax is most similar to Sensei rules. However, creating the rules requires learning their exact syntax, as no editor is provided. Sensei on the other hand provides a rule wizard, context-aware suggestions, and a GUI to edit the rules. Sensei rules also support more comprehensive features such as the concept of untrusted variables and support for libraries, which were explained in detail in Section~\ref{sec:features}.

\begin{lstlisting}[language={xml},caption={SecureAssist rule to discover use of DES},float,label={lst:SAexample},literate={\ \ }{{\ }}1,xleftmargin=12pt] 
<Match>
  <QualifiedName>javax.crypto.Cipher</QualifiedName>
  <Method>getInstance</Method>
  <Arguments>
    <Argument>
      <Index>0<Index>
      <Value>
        <ComparatorOperator>equals</ComparatorOperator>
        <ExpectedValue>DES</ExpectedValue>
        <ComparatorType>String</ComparatorType>
      </Value>
    <Argument>
  </Arguments>
</Match>
\end{lstlisting}

\begin{lstlisting}[caption={Sensei rule to discover use of DES},float,label={lst:SAexample2},literate={\ \ }{{\ }}1,xleftmargin=12pt]
search:
  methodcall:
    name: "getInstance"
    type: "javax.crypto.Cipher"
    args:
      1:
        type: "java.lang.String"
        value: "DES"
\end{lstlisting}

Rule packs are distributed as JAR files and the tool provides a Rulepack Configurator very similar to Sensei's Rule Manager.

\subsubsection{Veracode}
Veracode offers two tools. The Veracode Static Analysis (VSA) is a SaaS platform that is similar to Fortify on Demand~\cite{veracode}. Veracode Greenlight (VG) is an IDE plugin, similar to Fortify Security Asisstant.

VSA performs static analysis scans on compiled bytecode of web applications in 23 programming languages. Because it does not need access to the source code it can also analyse frameworks and libraries used in the project. VSA provides integrations with popular ticketing systems, CI/CD tools and three IDEs: IntelliJ, Visual Studio, and Eclipse. All these integrations offer the possibility to start scans and download the results. Veracode focuses heavily on not only detecting vulnerabilities but also guiding remediation. To that extent, they provide detailed instructions and videos. There is even the possibility to schedule a one-on-one conference call with a consultation expert. This expert can help the developer determine whether an issue is a false positive or what the best remediation is for a detected vulnerability. Scheduling such a consultation will usually take about three days. Veracode does not encourage or provide help to share the knowledge that is gathered by the developer during such a consultation session with their peers. 

The company claims most scans finish in under an hour. This means the feedback cycle is rather long compared to the other tools. Since the scans are performed on binaries, they are not able to provide quickfixes as Sensei does, which is unfortunate for a solution otherwise very focused on remediation.

Veracode promotes a low false positive rate of 5\% and hence discourages rule customization. Rule customization would also be much harder, since VSA analyzes compiled bytecode, not source code. VSA does not allow to disable rules or issues individually, but lets companies define a custom security policy for their application. Setting a policy configures the conditions used to evaluate results of  a scan, and helps decide if the build should break or be accepted. In these policies it is possible to add rules that disable certain CWE entries, category of flaws, or severity of flaws. Veracode offers Program Management Support, where a Program Manager will help define these policies, and gradually increase their requirements. This helps guarantee developer usability during roll-out. Developers will first be encouraged to resolve the most severe issues. In later stages when a tighter policy is set, they are exposed to additional issues. Although a new policy does not provide as granular control as a new rule in Sensei, this feature and roll-out procedure closely resemble the best practices described in Section \ref{sec:rollout}.

VSA offers a dashboard to track scan results over time. This displays the number of flaws per scan, tracks which ones are new, and organises the existing flaws into severity categories.

VG is an IDE plugin for Eclipse, IntelliJ, and Visual Studio. It is a light-weight version of VSA that is scanned locally. Since the scans are performed on bytecode, it requires a successful build. VG can be configured to scan automatically by using the Automatic Build option in the IDE. Scans are not real-time like Sensei but take around 3 seconds, after which the results are not shown in the IDE editor, but in a separate pane. Double clicking an issue in this pane will open the editor at the relevant location in code. Like VSA, VG is unable to provide quickfixes, but provides a lot of detailed information to the developer.

\subsubsection{Checkmarx}
Checkmarx Static Application Security Testing (CxSAST)~\cite{cxsast} is a static analysis tool that perfoms source code scans. It has support for over 25 coding and scripting languages, including Java, C\#, and python. Similar to Fortify and Veracode, CxSAST has IDE plugins for Eclipse, Visual Studio, and IntelliJ. Again, and still in contrast to Sensei, these plugins do not perform any local scans but instead allow uploading the source code to CxSAST. They provide an interactive way to view the scan results by marking the relevant code in the IDE editor. 

Checkmarx claims flexible rules lead to higher accuracy, and have a very extensive Query Language (CxQL)~\cite{cxaudit} to create and adapt rules.  Managing queries is done in the CxAudit tool, this tool allows enabling and disabling individual queries. Here, new queries can also be added in a Query Source Pane. It is possible to export a set of queries from this tool to use in different applications. The source pane however provides little help to write and especially debug new rules. Since the rule-writing tool is independent from the scanning tool and the IDE, it requires long iterations to optimize rules compared to the instant feedback in the Sensei rule editor where the results of rules are updated live. Vulnerabilities marked in the scan results have a category but no descriptions are provided. This means that little help is provided compared to the remediation suggestions and quickfixes of Sensei. More details about the control flow leading to the vulnerability are clearly marked in the IDE plugins and can help an experienced developer find the best place in source code to resolve the problem. A similar feature could be developed for Sensei's concept of trusted input, but it was decide to omit this to avoid unnecessary clutter in the IDE.

Checkmarx does provide an integration between CxSAST and its training service CxCodebashing. This way developers can learn about the vulnerability and how to fix it in an interactive way. This integration is similar to the integration between Secure Code Warrior and Fortify on Demand, as well as the training links in the full coding guideline description of Sensei.

\subsubsection{Snyk}
Snyk~\cite{snyk} is a tool designed to monitor and fix insecure dependencies. It will not look for vulnerabilities, but will mark dependencies with known vulnerabilities and helps to remediate by updating or replacing dependencies. It started as a plugin for code repositories, such as github, gitlab, and bitbucket. Fixes in these plugins are in the form of automatic pull requests that fix the dependencies. Following the shift left movement Snyk also developed IDE plugins for intelliJ and VS Code to detect insecure dependencies earlier in the SDLC. The tool is suitable for use in the development phase since scanning for insecure dependencies is light-weight and it is mostly trivial to propose quickfixes.

\subsubsection{Aside}
The OWASP ASIDE/ESIDE~\cite{aside} project consist of two branches, the ASIDE branch that focuses on detecting software vulnerabilities and helping developer write secure code, and the ESIDE branch that focuses on helping students in acquiring secure programming knowledge and practices.

Application Security IDE (\emph{ASIDE}) performs fast scans of the code in Eclipse, but unlike Sensei the scans need to be started manually. Besides detecting vulnerabilities they also provide quick fixes for some issues. The quick fixes require the developers to choose from a list of options, which could overwhelm them. In previous research a large number of false positives were detected~\cite{xie2011aside}, however, most of these are what is considered protection for future use in this paper. They are cases where best practices should be applied even if their violation is not yet exploitable at this point in development. They also mark variables in the code that are tainted, this could be compared to Sensei's concept of untrusted input. Untrusted input in Sensei is not currently marked to avoid unnecessary clutter. 

The goal of ESIDE~\cite{eside,whitney2018embedding} is to provide information and training at all times during the education. Its rules can not be configured and the tool does not provide quickfixes. However they provide explanation in external web pages linked from Eclipse. Their information is similar to our full coding guidelines where information on APIs and a correct code example is provided. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Penetration Testing}


\subsection{Static Analysis}





