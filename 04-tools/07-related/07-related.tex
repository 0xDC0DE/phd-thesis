\chapter{Security in software development}
\label{ch:related}

Software security is a relatively new field~\cite{mcgraw2004software}, but many tools and practices have already been developed that have caused great advancements.
Many guides exist to help you decide which tools are appropriate for your project.
In this chapter, I want to extend these guides so that you are better equipped to estimate the strengths of a tool for use in the paved path methodology.
I describe commonalities between tools in different phases of the \gls{sdlc} and how they can be deployed effectively.

For future reference, Appendix~\ref{app:battlecards} contains a number of battlecards with my thoughts on a few more tools.

\summarybox{
Security begins even before code is written.
Laws, legislations, and consumer demands all impact how much attention is given to security.
Besides lightweight linter tools, developers can also find help to produce secure code from patterns, libraries, and frameworks.
In the build phase, the use of new methodologies has driven the automation of building executables and installing dependencies, which has made it easier to test for use of vulnerable components.

Most security practices, however, take place in the test phase.
Many code review practices and tools exist, most of which allow customization of the rules through one of three methods: an \gls{api}, a custom query language, or a formatting language such as \gls{xml} or \gls{yaml}.
Finally, in the release phase, advancements in infrastructure as code have made it easier to securely deploy applications and manage infrastructure.
}

\include{04-tools/07-related/sections/00-plan}
\include{04-tools/07-related/sections/01-develop}
\include{04-tools/07-related/sections/02-build}
\include{04-tools/07-related/sections/03-test}
\include{04-tools/07-related/sections/04-release}

%
%\paragraph{CodeInspector}
%%%https://www.code-inspector.com/

%\paragraph{Pluralsight}
%%https://help.pluralsight.com/help/vs-code-extension
%
%\paragraph{RuleGuard}
%
%\paragraph{Explore.dev}
%%https://explore.dev/
%
%\paragraph{Deepcode}
%(Matias:)
%deepcode.ai
%Deepcode is a University project spin off (Spun of in 2016). It’s focus was on quality code, not security in specific.
%Focus on:
%* Accuracy
%* Speed
%* For developers
%When demoing, main focus went to the IDE plugin (Can also work in Pull request and in CD/CD). Demo was very slick. it shows errors and warnings, and it shows other places in the code where a developer made that change before, essentially they went through the entire history of checkins and make rules out of that (not really rules, it is in their AI/ML module). So it is not only finding, it does have a focus on real fixes, potentially in line with the code base, stuff that can actually work.
%AI/ML component is very interesting. AI/ML instead of rules based is very interesting. If this works, if they can pull that off, it is a good approach to get rid of manual effort and still be custom to the code (but that is not the focus, so this is not happening right now). It diminishes the number of researchers they have to have on staff to create rules. It reduces the time to value for customers using the solution.
%Compared to Semmle: Seems to have a lot of similarities. Started as a tool focused on quality, not specifically security. Was a university project first which was incubated, so not really a focus on making this work at scale. (Great for a demo, great in theory, great on a small code base, but what about the real world). However, from what they have shown, it looks better/easier/slicker/more mature than Semmle.
%If the demo works in practice on large codebases, then I think it will be a significant challenger for the established SAST solutions.
%I think there is an opportunity for SCW to be in there and educate the developer. The examples in the demo were simplistic (hardcoded passwords) so there was no need for training, but I can see a role for the SCW training platform with what I’ve seen
%Sensei, that becomes more interesting, but there are advantages and disadvantages. Sensei is still real-time, Snyk Code is when pressing a button, and in a different window. Sensei has a quick fix, Snyk does not have one. Sensei is more tailored to the code, Snyk is not. But then there are undeniable advantages of their approach. The ML/AI instead of rules should be better in terms of configuration, rules support, … if and only if this AI/ML thing work. And that AI/ML thing may show quicker value than Sensei, as the upfront work is less on Snyk code. Sensei feels more enterprise than Snyk code tbh, I don’t see them doing what we do at NetSuite, that AI/ML is too free form and can propose whatever.
%
%(Brysen:)
%I just watched the demo videos on their youtube channel.
%Sending your code to their servers is an annoying thing.
%The way they provide a “fix” is done by showing you examples of open source repos where this issue should have been fixed, but in their example it doesn’t even show the same code as the found vulnerability so effectively the user still needs to plow through the suggested changes and determine if they are right in which they still need a good too strong security knowledge.
%
%Specifically to Sensei, one thing we have to copy is showing an example. So the suggestion they make is together with an example of another place in the code where this is also the case (or where that same change was executed). That looked really cool. I think in Sensei that would work even better, because we should do that in the code base itself, and not on some random other open source project... My 2 cents

%\subsubsection{SecureAssist}
%SecureAssist~\cite{secureassist} is an IDE plugin targeting the discovery of security bugs in code. It is available for eclipse, intelliJ, VisualStudio, RAD, and Spring Tool Suite~\cite{sastinide}. Its scans are not in the IDE but on the enterprise portal. The results are sent back to the IDE once completed. This allows scanning without preventing the developer from continuing his work, which contrasts with the Fortify Security Assistant, that prevents developers from changing the code during a scan. Remediation is provided in the form of descriptions that explain the attack and provide some code examples but the tool does not provide quick fixes~\cite{secureassistide}. 
%
%Rule packs are distributed as JAR files and the tool provides a Rulepack Configurator similar to Sensei's cookbook Manager.

%\subsubsection{Aside}
%The OWASP ASIDE/ESIDE~\cite{aside} project consist of two branches, the ASIDE branch that focuses on detecting software vulnerabilities and helping developer write secure code, and the ESIDE branch that focuses on helping students in acquiring secure programming knowledge and practices.
%
%Application Security IDE (\emph{ASIDE}) performs fast scans of the code in Eclipse, but unlike Sensei the scans need to be started manually. Besides detecting vulnerabilities they also provide quick fixes for some issues. The quick fixes require the developers to choose from a list of options, which could overwhelm them. In previous research a large number of false positives were detected~\cite{xie2011aside}, however, most of these are what is considered protection for future use in this paper. They are cases where best practices should be applied even if their violation is not yet exploitable at this point in development. They also mark variables in the code that are tainted, this could be compared to Sensei's concept of untrusted input. Untrusted input in Sensei is not currently marked to avoid unnecessary clutter. 
%
%The goal of ESIDE~\cite{eside,whitney2018embedding} is to provide information and training at all times during the education. Its rules can not be configured and the tool does not provide quickfixes. However they provide explanation in external web pages linked from Eclipse. Their information is similar to our full coding guidelines where information on APIs and a correct code example is provided. 
%
%
%
%
%
%
%