%\part*{Vision}
\chapter{The paved path methodology}
\label{ch:vision}

\epigraph{You must unlearn what you have learned.}{\textit{Yoda}}

%CONTEXT: background for less specialized readers and establish or recalls the importance of the problem
Security automation has made it easier to identify software \glspl{vulnerability}, but this has had little impact on the prevalence of \glspl{vulnerability} in almost all types of software. 
%NEED: motivates the audience by stating the difference between the desired and actual situation
To turn the tide, fundamental changes need to be made to software development practices. The ability to detect \glspl{vulnerability} alone is not enough, we need better processes and tools to prevent and fix \glspl{vulnerability} in a scalable way.

% TASK: states what the author undertook to address the need (first person)
During the past four years I have researched developer and security practices while working for the company \gls{scw}\footnote{\url{https://www.securecodewarrior.com/}}, in collaboration with Ghent University.
During this time I built a vision of collaboration between developers and the security team, which I have named the paved path methodology.
% OBJECT: clarifies what the chapter covers without repeating the task, in the active voice, present tense
In this chapter, I describe the observations made during my research and the vision I have built.
In the remainder of this work, I explain how this vision can be achieved through more intentional education (Part~\ref{p:education}) and tools (Part~\ref{p:tools}).

\summarybox{
With the paved path methodology, I have built a vision to make software security a shared responsibility between the security team and developers.
When using this methodology, the security team should not force security testing on developers, but instead gradually build a paved path for developers to follow.
Developers will then follow that path, as it is the easiest way to achieve their goals.
The discussed practices make it easier for developers to produce secure code and fix existing \glspl{vulnerability} in a scalable way without harming their productivity.
To support the paved path methodology better education and tools should be provided that are more human-centered and keep the developer experience in mind.}

% FINDINGS: state the main results in a way that both less and more specialized readers find helpful
%The discussed practices make it easier for developers to produce secure code without harming their productivity.
% CONCLUSION: interprets the findings, states the SO WHAT
%Not only will newly produced code be more secure, but existing vulnerabilities can also be fixed in a more scalable way.

\section{A story of increasing collaboration}
% maybe story is not the best word... a vision? a philosophy? 
\subsection{The security team}
%(CONTEXT)
% Background for non-specialized readers
% Establish the importance of the NEED
Security issues still exist in all software products: 100\% of the applications tested by Trustwave in 2017 displayed at least one \gls{vulnerability}~\cite{trustwave}. 90\% of these \glspl{vulnerability} are caused by problems or oversights in underlying code~\cite{softwareassurance}. They are the results of mistakes made by the programmers during development. These are not new problems, the same types of \glspl{vulnerability} have been widely present in software for decades.

The (application) security team (\Gls{sec} or \Gls{appsec}) at these companies is responsible for evaluating the software and finding all the \glspl{vulnerability}. With the use of security tools much of this process is automated and so they have become quite competent at finding problems in the code. In fact, many of the reported numbers are collected through security tools used by these very teams~\cite{owasptop10data}. 

The ability to detect \glspl{security problem} alone is not sufficient, more focus should be on preventing and fixing them in a scalable way.
Once these (potential) \glspl{vulnerability} are discovered, it is up to the development team (\Gls{dev}) to fix them. 
In order to help them manage this task, the security team pushes discovered \glspl{vulnerability} into a \gls{bugtracker}. They even organise the \glspl{vulnerability} by category and prioritize them by severity of impact. To actually understand each \gls{issue}, and to fix them in a consistent way, however, developers are often on their own.
On average a company hires only 1 security expert for every 75-200 developers~\cite{bsimm9, bsimm11, shiftleftsurvey}. This expert simply cannot assist each of those developers. 
It is evident that security is no longer just the task of this expert. Every developer should be responsible for producing code securely from the start. 

\subsection{The development team and the operations team}
In order to make producing secure code more scalable, we can take a look at the improved collaboration between developers and operators in the \gls{devops} movement.
The operations team (\Gls{ops}) used to be the only one responsible for testing and deploying code delivered by developers.
Once the code was finished, and working on the developer's local machine, it was \textit{thrown over the wall} for the operators to deal with.
The \gls{devops} movement aims to make this a more shared responsibility between \gls{dev} and \gls{ops}.
Ideally, the two become one integrated \gls{devops} team. In reality they are often still two closely related teams. 

This close collaboration between the two is key.
The operations team provides a service to developers that enables them to test and deploy their own code. They do not force automation but gradually build a \gls{cicd} pipeline. This pipeline is different for each project and heavily depends on the chosen technology stack for that project.
Through this pipeline, developers are able to check in smaller pieces of code more frequently and quickly receive feedback. DevOps has quickly gained popularity, 43\% of developers report using its practices and 80\% of developers think using DevOps practices is important~\cite{stackoverflow2020}.

%(NEED) 
The automated \gls{cicd} pipeline also benefits the security team.
Because of the faster release and deploy times, fixed security problems find their way into production faster.
The \gls{cicd} pipeline also allows them to automatically run static and dynamic analysis tools more easily.
On bigger projects, such tools easily need a couple of hours to complete their analyses. This is not ideal for \gls{devops} pipelines, where tight feedback loops are important.
Almost all developers (96\%) report that the biggest inhibitor to productivity is the disconnect between development and security workflows~\cite{shiftleftsurvey}.
A guideline that is sometimes mentioned for \gls{devops} tools is the coffee test.
The idea behind this test is that all automations should be finished within the time it takes a developer to get a cup of coffee after checking in their code. 

To solve this, the security team can tune the tools so that they run more lightweight analyses. One way to do this is by disabling certain rules.
More lightweight analyses do not hinder the developers' productivity and also allow for fast feedback of the analysis results. Of course, the full scan should still be run regularly, for example on a daily basis. 
Faster feedback through lightweight analyses is definitely an improvement over delayed pushing of \glspl{security problem} into a \gls{bugtracker}, but it is not enough. 
The \gls{cicd} pipeline may be convenient to automate security, but it is still disconnected from the development workflow.
There is still only one expert to help up to 200 developers, so the problem of preventing and fixing \glspl{security problem} at scale remains.
The security team acknowledges this, as they rank creating developer-friendly workflows as their top priority, even ahead of protecting the production software itself~\cite{shiftleftsurvey}.

\subsection{Three is a party}

%(TASK) 
Similarly to the \gls{devops} movement, security should become a shared responsibility between the development (or \gls{devops}) team and the security team.
The security team should not generate reports and \textit{throw it over the wall} to developers.
Instead, they should closely collaborate with developers to enable them to produce secure code consistently. This can be achieved through the \textit{paved path methodology}. 

Like the operations team, the security team should provide a service to developers to make it easy for them to secure their own code in a consistent way.
They should not force security testing on developers, but instead gradually build a \textit{paved path} for developers to follow.
Just like the \gls{cicd} pipeline, this paved path should be tailored for each project and will heavily depend on the technology stack for that project.
Together, developers and security experts should build standards and patterns that lay out the paved path for their project.
For example, they can decide together how key management should be handled by selecting the library and the tools needed.
The correct way to handle key management will depend on the programming language, the framework, and the type of software application.
Developers will then follow the paved path, as it is the easiest way for them to implement a feature that needs key management.
Automated checks can be included in \Gls{cicd} by operators to prevent any other ways of handling key management.

In order to achieve this close collaboration, the security team needs to be deliberate in their approach. Their focus should not just be on the code, but also on the developer.
They should be mindful of their communication and be empathetic. This way \gls{sec} and \gls{devops} can truly come together to form a \gls{devsecops} team with aligned goals.

\section{Improved culture}
This shift towards collaboration starts with a shift in culture.
Historically, the development team and the security team have developed somewhat of an adversarial relationship.
The security team has to constantly fight to make security a priority during development.
They are aware of the risks and the costs related to poor security and they try their hardest to find all the problems in the code.

Since the security experts are understaffed and unable to adequately assist developers, all they end up doing is slapping developers on the wrist by pointing out their mistakes.
In doing so, the security team loses an opportunity to build a trusted relationship and provide a valuable service to developers.
This kind of interaction understandably causes resistance and even contempt from the developers towards the security team.
This in turn gives security experts the impression that developers do not care about security.
Furthermore, it is often the case that security experts do not have sufficiently intimate knowledge of software development.
Even with the right intentions, they commonly lack the skills, or at the minimum the credibility, to properly advise developers in improving development processes and standards.

There is a clear need for mutual respect, empathy, and better cooperation.
The security team needs to empathize with developers and provide a meaningful service to them.
But to do so effectively, the developers need to empathize with the security team and work constructively to make security an inherent part of the software development process. This culture of cooperation and empathy is started by aligning goals, and aligning language among the two teams.

\subsection{Aligning goals and metrics}
To make security a shared responsibility, we have to meet developers in the middle.
Developers, and the business as a whole, want to ship features regularly and with predictable speed.
It is hurtful to the business to delay releases for security concerns when customers are promised these new features.
The security team needs to understand this, and get involved from the start.
Security becomes a shared responsibility, but so does building and deploying fast.
Moreover, faster building and deploying also benefits security, as any security problems that eventually show up in production can also be patched and updated faster.

The mutual goal of a \gls{devsecops} team should be to reduce the number of vulnerabilities in later stages of the development life cycle, while also still maintaining or even improving deployment metrics~\cite{doddevsecops}.
It then becomes clear that improving one at the detriment of the other, is not real improvement.

\subsection{Aligning communication}
\label{sec:communication}
The culture of mutual empathy is also improved with more deliberate and conscious communication.
Instead of shaming or even punishing developers when problems are introduced in the code, the security team should try to understand the developer's challenges, and offer help.
When the paved path has been built through collaboration, this implies the guidelines for the project have been mutually agreed upon.
When such guidelines are violated, it becomes easier to demonstrate empathy and to show good intent.
The security team can ask developers if the guidelines are insufficiently clear, if they lack recommendations for specific edge cases, or if there is any other valid reason the developer did not adhere to the guideline.

By doing so, they can more easily avoid security jargon and speak in clear, mutually understood language.
They will talk about a \textit{guideline violation} instead of a \textit{\gls{vulnerability}}, \textit{\gls{exploit}}, or a \textit{\gls{security defect}}.
Terminology with subtle differences in meaning that are likely not fully understood by developers.
There is no need to talk about \gls{vulnerability} types or use acronyms, instead the focus can be on the desired result, spoken in development terms.
So instead of warning of a potential \gls{xss} \gls{vulnerability}, the security team can indicate a lack of output escaping and request the use, or development, of a library for this purpose.

By improving culture, and creating more empathy between the security team and developers, the security team should be better equipped to integrate security and development workflows without hurting productivity.
The integration of these processes can be facilitated with appropriate technology that is more suited to developers.
Instead of forcing re-purposed security tools designed for security professionals onto developers, new technology should be used that is built with the developer experience in mind.

\section{Developer-minded security education}

Deliberate security education that keeps the developer experience in mind should be:
\begin{itemize}[noitemsep]
    \item \emph{relevant} to the developer's work,
    \item \emph{efficient} in achieving the developer's needs,
    \item \emph{usable}, engaging, fun.
\end{itemize}

The goal of security education is to teach developers the knowledge and skills necessary to produce secure code. To achieve this goal, we want the acquired information to be stored in long-term memory. Every piece of knowledge in long-term memory is stored as a series of associations~\citep{dirksen2015design}. 

If a developer learns about the programming language Kotlin, this can be encoded in their memory under the following associations:
\begin{itemize}[noitemsep]
    \item Programming languages used for Android apps.
    \item Programming languages designed by JetBrains.
    \item Things I learned about while eating pizza.
\end{itemize}

More associations, and more meaningful associations, make it easier to retrieve information from memory. Education should be designed to allow for many meaningful associations.
We often make numerous unconscious associations by utilizing all of our senses, such as the association between Kotlin and pizza in the example above. While these associations may seem random, they are still used to retrieve information and can even be used to design better education~\citep{dirksen2015design}. 

\subsection{Relevant education}
Some of the associations made while learning secure coding skills will be related to the practical context in which the developer is taught. This context should resemble the one where the acquired skills are applied, as this will improve retrieval of the content. This phenomenon is one of the reasons why pilots do not learn to fly a plane through slide presentations but by using flight simulators~\citep{dirksen2015design}. Similarly, developers should not learn secure coding through books or slide presentations. 

The learning context should resemble the developer's work context. They should receive education in their office or home office, by using their own computer, their own keyboard and mouse, and through actual code. This code should be in the same programming language and framework they are using daily. Even the type of software should be relevant to the developer's work. A developer working on mobile applications should be taught secure coding by means of code for mobile applications.

\subsection{Efficient education}
%Efficiency of the education also has a big impact on the developer experience. 
Retention and recollection of the material is not just improved through more and better associations, but also through repetition. Repetition reinforces the associations in memory, this makes them stronger and more durable~\citep{dirksen2015design}.
Of course, we can not expect developers to study for hours on a daily basis, education should be possible with minimal harm to their productivity.

Finding the right balance between repetition and efficiency is a difficult problem. How much repetition is needed depends on the individual learning pace of each developer. A teacher can easily adapt their pace to the students in their classroom.
However, in classroom teaching, much of the practical context and other relevant aspects mentioned in the previous section are easily neglected. In online learning it is more practical to allow each developer to train using their own programming language and their own machine. Online learning also allows for better scalability. But online systems are worse at adapting to the learning pace of each user. A possible solution to this problem is described in Part~\ref{p:education} of this work.

From the developer's perspective, relevance and efficiency are closely related.
As explained in the previous section, education in the right language and framework allows for better recollection because contextual associations are made in memory. But using the right programming language also ensures that the developer is being taught problems and solutions that are immediately applicable to their work.
Many learning resources teach secure coding concepts in a different programming language, or by using pseudo-code. While most developers will be able to apply the learned concepts to their own code, they will still need to research specifics on their own to do so.

Efficiency can also be improved by providing exercises that help developers acquire the right skills.
These skills are recognizing insecure code patterns and (re)writing their code so that it is secure.
They need to be taught the \textit{paved path}, and how to stay on it. 
Security experts, on the other hand, are often occupied with testing whether potential vulnerabilities can be exploited. This is frequently reflected in security education; developers are handed penetration testing exercises. Such exercises certainly have a place in developer education, as they create new and strengthen old associations in memory. 
However, in order to teach developers secure coding skills more efficiently, the focus should be on defensive exercises, i.e., exercises that teach the developer to recognize insecure code and to prevent or fix insecurities.

\subsection{Usable education}
When it comes to online learning, usability and engagement go hand in hand. By improving the usability of the education, engagement is increased as well~\cite{garzotto2007investigating,sweetser2005gameflow,febretti2009usability,dahleez2021higher}. 
Engagement has been shown to have a clear positive effect on learning~\cite{hamari2016challenging,dahleez2021higher}.
Because online learning often suffers from low engagement, extra care should be put into usability~\cite{hadi2016driving}.

Improving the relevance and efficiency of education will indirectly make it more usable, as less effort will be needed to understand and apply the learned lessons.
Efficient training, that can avoid unnecessary repetition, will make it less likely that a developer gets bored due to this repetition.
On the other hand, too much efficiency can cause the learning curve to be unnecessarily steep. When developers have difficulty keeping up with the material, they might experience frustration. A bored or frustrated developer is likely to lose interest and even to disengage from the education. When instead a developer continuously experiences the right level of challenge, they are experiencing a state of flow~\cite{joo2012model,csikszentmihalyi2014learning}.
Flow affects learning both directly and via increased engagement~\cite{hamari2016challenging,van2008difficulty,joo2012model}.
Finding the right difficulty for each user to keep them in a state of flow is a challenge tackled in Part~\ref{p:education} of this work.

Besides keeping users in a state of flow, usability and engagement can also be improved through other means.
One way to do this is by providing a structured learning journey that lays out a clear path and expectations~\cite{hadi2016driving}.
This structured journey allows online learning to replicate a more traditional learning experience.
Another way to improve usability and engagement is through increased interactivity of the education~\cite{hadi2016driving}.
It is possible to encourage interactivity between learners by adding gamification and competitive aspects such as high scores, leaderboards, badges, achievements, or even prizes.
Promising rewards like these upon completion of certain tasks has a clear effect on learner motivation and hence engagement.
Finally, engagement can also be increased through the presentation of the learning material. Many developers are problem solvers at heart.
They enjoy trying to understand a problem and coming up with an elegant solution.
Rather than handing them descriptive learning material, it will likely improve engagement when developers are allowed to figure out the answer for themselves.
In online learning this is not easily achieved, since automated grading of open ended questions is difficult.

A form factor that still allows for some type of problem solving that is easy to correct for a computer is multiple choice.
This type of questions teaches a developer to \textit{recognize} the right answer among several~\citep{dirksen2015design}.
In reality, a developer also needs to \textit{recall} the material without being given options to choose from. However, such a recollection activity can be turned into a recognition activity by providing so-called scaffolding~\cite{maybin1992scaffolding}. In the next section I explain how security tools can be designed to provide this scaffolding during development.

\section{Developer-minded security tools}
Education alone is insufficient for developers to produce secure code.
Our memories are not infallible and regression of knowledge is possible.
Other times developers sufficiently remember, but fail to apply their knowledge in practice~\cite{xie2011programmers}.
Security tools should help close this gap between knowledge and practice. 

Developers are known to dislike and often disable security tools during development~\cite{shiftleftsurvey}. 
They frequently perceive them as one of the biggest inhibitors of productivity. 
A tool supporting the paved path methodology should in the first place be designed as a developer tool, security should come as an indirect result. 

A developer tool should:
\begin{itemize}[noitemsep]
    \item provide \emph{relevant} feedback to the developer's work,
    \item be \emph{efficient} and improve productivity instead of hurting it,
    \item be \emph{usable} and well integrated into developer workflows.
\end{itemize}

To the developer, the goal of a tool is to make development easier.
It should help boost their productivity and lower their cognitive burden.
From the developer's perspective, security is a non-functional requirement and not the main objective.
By using the paved path methodology, such a developer tool can improve the security of the code.
Good development teams are narrow in their allowed practices, as this makes it more feasible to understand and maintain the software.
In order to be successful, the security team should contribute and help decide these allowed practices.
Security will then simply be a result of sticking to these practices, a result of following the path of least resistance.

\subsection{Relevant tools}
To lay out this paved path, the security team and the development team have to work closely together.
Together, they need to create guidelines that specify the preferred solution for a security-critical feature that is needed by the development team.
These guidelines should not be conceptual guidelines like the security team is used to creating, as those are hard to translate into code by developers.
Instead, the security team should work together with members from the development team to make specific, \gls{api}-level guidelines.
These guidelines lay out which libraries or even which specific library calls are to be used in the project.

When the developers are using libraries for a specific purpose, they are focused on the functionality of their code. Security is often orthogonal to that purpose.
When a library is used insecurely by a developer, we should not blame the developer for this, but instead blame the design of the library.
When laying out the paved path, it is important that no security bugs can be introduced by \textit{using} the chosen library, and instead all possible bugs are contained within the \textit{implementation} of the library itself.
Custom (wrapper) libraries may need to be developed that are inherently safe and that can be freely used by the developers.

A tool supporting the paved path methodology should then remind the developer of the agreed guidelines any time they stray from the paved path.
Any library calls or custom methods that the developer uses and that are functionally similar to the library provided by the security team, should be marked by the tool.
This should be done regardless of the security of the used library. The goal of the tool is not to evaluate the security of the code, but only its adherence to the guidelines.
Since these guidelines are customized for each project, this guarantees that the feedback will always be applicable and highly relevant to the developer's work.
The tool should hence be easy to configure so that project-specific guidelines can be enforced.

\subsection{Efficient tools}
It is worth emphasizing that the enforced guidelines can have a wide range of applications. They can be used to migrate to a new library, to deprecate old functions, enforce code quality guidelines, improve legibility, and so on. 
Such a tool helps developers share their knowledge and guide each other to improve the quality and maintainability of the software. 

To assert that the developer is adhering to the guidelines, only local analyses are required. There is no need for complex data flow or control flow analyses. The required local analyses can be done in real time, as the developer types. 
A tool that supports the paved path methodology is hence efficient and actively improves the productivity of the developer instead of hurting it.

In contrast, traditional security tools will try to assert the absence of certain bugs in the application. To do this, they have to analyse all possible data flows. Even moderately complex applications contain complex data flows that are difficult to reason about~\cite{kern2014securing}. This complexity leads to slow scanning speed and, to the developer's standards, insufficient quality of results. 

When using traditional security tools, developers report this poor quality of feedback and slow scanning speed as big inhibitors of their productivity~\cite{shiftleftsurvey}.
These security tools are of course still valuable to the security team to help them create and maintain libraries, but they are not the right tool to provide to developers.

Because the tool is able to provide instantaneous feedback, it makes sense to do so in the developer's \gls{ide}.
It can then make all necessary information about the agreed guidelines available in the \gls{ide} as well.
This way, the developer is able to access it without making a context switch to consult outside documentation, again boosting productivity.

The guidelines describe which library calls to use, that is, they describe the desired outcome.
Because of this, the tool that is enforcing the guidelines is able to provide targeted and relevant remediation guidance that can even be automated by the tool.
%This can be done through the use of code quick fixes.
%These code transformations are an existing \gls{ide} feature that the developer is familiar with and that are commonly used for
%marking generic coding best practices.
%Avoiding the need for research and even automating the remediation of the guideline violation, greatly improves the productivity of the developer.

The lack of such remediation guidance is a frequently mentioned inhibitor of productivity in traditional security tools~\cite{shiftleftsurvey} which usually can only provide generally applicable guidance~\cite{baset2017ide}.

\subsection{Usable tools}
Avoiding the need for research does not only boost productivity, it also makes the feedback easier to understand.
Because the information is presented as a guideline, it is immediately obvious for the developers what is expected of them to fix the problem. Adhering to a coding guideline is trivial, and does not require knowledge of the possible vulnerabilities it mitigates.

When the developer is provided feedback that describes potential vulnerabilities, on the other hand, solving the problem is a more complex task. Even if the developer is already familiar with the \gls{vulnerability} and does not need to research it, the focus in the case of a potential bug report is on determining whether this particular instance can be exploited or not. If it is determined insecure, the developer needs to research a solution, apply it, and verify whether no functional changes were made. This requires a larger cognitive effort. Traditional security tools are meant to be just that, tools for the security team.

The usability for developers is improved because the tool is designed with the developer in mind.  
The tool resides in the developer's \gls{ide} and reuses existing features to display information and provide remediation guidance.
It is closely integrated in the developer's workflow and is easily and frequently used for other purposes than security.

\section{This book}
% OBJECT
% Why this document, how is it structured?

In Part~\ref{p:education} of this work, I describe how to create better security education and keep the developer experience in mind.
I analyzed the behaviour of over 175,000 developers receiving security education on the online learning platform created by \gls{scw}. 
I designed, implemented, and evaluated an \gls{its} that selects the most appropriate exercise for each developer at each point in time.
This \gls{its} ensures that developers are receiving \textit{relevant} training and acquire the necessary skills \textit{efficiently} while still being \textit{usable} and engaging.
\changed{The research in this part is based on a large data set made up of data from developers at large corporations.
This data is rigorously analyzed and the results are strong evidence towards the proposed solutions.}

This part is based on:

\begin{itemize}
    \item 
    \textbf{Method and System for Adaptive Security Guidance}\\
    \underline{Pieter De Cremer}, Matias Madou, Nathan Desmet, Colin Wong\\
    \emph{US Patent Application 16/234,037}, 2018\\
    \emph{US Patent Publication US20200211135A1}, 2020
    \item 
    \textbf{Create a Certification Framework for Secure Development Practices}\\
    Matias Madou, Brian Chess, \underline{Pieter De Cremer}\\
    \emph{Enhancing Software Supply Chain Security}, NIST, 2021
\end{itemize}

In Part~\ref{p:tools}, I describe the goals and requirements for a security tool supporting the paved path methodology.
I helped with the design and requirements of this tool that is implemented by the engineering team at \gls{scw} and evaluated it both in a controlled experiment as well as in professional settings.
The tool, called Sensei, functions as an \gls{ide} plugin and reuses existing \gls{ide} features that the developer is familiar with.
It provides remediation guidance in the form of quick-fixes and offers several features improving usability for the developer.
Sensei is designed as a developer tool first, improving productivity and reducing the cognitive burden of development.
It enables close collaboration between the development team and the security team, and ensures that secure code is being produced in a scalable way.
\changed{The research in this part is mostly based on observations at companies and second hand information acquired through interviews.
Since the research subjects are developers working for paying customers at Secure Code Warrior, they were not able to invest large amounts of time to collaborate in this research.
While the results from these interviews do not disprove the hypothesis of this work, they are also not the result of rigorously designed experiments and hence can not be interpreted as strong evidence towards the proposed solution.}

This part is based on:

\begin{itemize}
 \item 
 \textbf{Sensei: Enforcing secure coding guidelines in the integrated development environment}\\
 {\small \underline{Pieter De Cremer}, Nathan Desmet, Matias Madou, \mbox{Bjorn De Sutter}\\}
 In \emph{Software: Practice and Experience}, 2020
    
 \item 
 \textbf{Method and Apparatus for Detecting and Remediating Security Vulnerabilities in Computer Readable Code}\\
 \underline{Pieter De Cremer}, Matias Madou, Nathan Desmet, Colin Wong\\
 \emph{US Patent Application 17/005,685}, 2020
 
 \item 
 \textbf{Method and Apparatus for Generating Security Vulnerability Guidelines}\\
 \underline{Pieter De Cremer}, Matias Madou, Nathan Desmet, Colin Wong\\
 \emph{US Patent Application 17/005,729}, 2020
 
 \item 
 \textbf{Promote a Paved Path Secure Development Methodology}\\
 Matias Madou, Brian Chess, \underline{Pieter De Cremer}\\
 \emph{Enhancing Software Supply Chain Security}, NIST, 2021
\end{itemize}

%Finally, in Chapter~\ref{ch:conclusion} we summarize the results and offer some perspectives that remain future work.
Finally, in Part~\ref{p:parth-three}, I describe related tools and practices, and offer my opinion on how they can be used to achieve a more human-centered approach to software security.
Some of the discussed tools and practices have been thoroughly researched and are used in industry, other work is more recent and innovative. 
This includes practices around governance, training, development, building, and deploying of software products.

Other contributions as a researcher at 
\gls{scw} that are not detailed in this dissertation include:

\begin{itemize}
    \item
    \textbf{Actionable Software Security for Developers}\\
    \emph{IWT bedrijfssteun}, 2015\\
    As part of this project I surveyed and researched security problems introduced in Java applications by incorrect use of common \glspl{api}.
    Out of this research I created close to 100 rules that can be enforced in the Sensei IDE plugin. 
    
    \item 
    \textbf{How to scale application security training for developers}\\
    \emph{VLAIO O\&O project}, 2017\\
    As part of this project I surveyed and researched common security problems introduced in mobile applications created using the Android \gls{api}.
    From this research, I created a mobile application and introduced vulnerabilities into it to create 138 exercises on the \gls{scw} training platform.
    
    \item
    \textbf{Aanpasbare ondersteuning voor veilige software ontwikkeling}\\
    \emph{VLAIO O\&O project}, 2019\\
    I invented and described automatic rule creation methods for the Sensei IDE plugin to be developed with this funding. The methods include:
    \begin{itemize}
        \item Improved manual creation of rules through rule editor
        \item Static generation of rules based on static analysis tool results
        \item Static generation of rules based on code repository history
        \item Dynamic generation of rules based on developer behaviour
    \end{itemize}
    
    \item 
    \textbf{Secure Code Bootcamp}\\
    \emph{\gls{esf} project}, 2020\\
    I was part of the design and product management of a mobile application to provide secure coding education to developers.
    This application is now freely available in the Android Play store and the iOS App store.
    
\end{itemize}

\changed{
\section{Publication output}
My publication output during my research includes one journal paper, two position papers, and four patents.}

\changed{
\begin{itemize}
    \item 
    \textbf{Sensei: Enforcing secure coding guidelines in the integrated development environment}\\
    {\small \underline{Pieter De Cremer}, Nathan Desmet, Matias Madou, \mbox{Bjorn De Sutter}\\}
    Journal paper, peer reviewed and published~\cite{de2020sensei}.\\
    In \emph{Software: Practice and Experience}, 2020
    \item 
    \textbf{Create a Certification Framework for Secure Development Practices}\\
    Matias Madou, Brian Chess, \underline{Pieter De Cremer}\\
    Position paper, peer reviewed and published~\cite{nist-enhancing}.\\
    \emph{Enhancing Software Supply Chain Security}, NIST, 2021
    \item 
    \textbf{Promote a Paved Path Secure Development Methodology}\\
    Matias Madou, Brian Chess, \underline{Pieter De Cremer}\\
    Position paper, peer reviewed and published~\cite{nist-enhancing}.\\
    \emph{Enhancing Software Supply Chain Security}, NIST, 2021
    \item 
    \textbf{Method and System for Adaptive Security Guidance}\\
    \underline{Pieter De Cremer}, Matias Madou, Nathan Desmet, Colin Wong\\
    Patent application, reviewed and granted~\cite{patent-publication}.\\
    \emph{US Patent Application 16/234,037}, 2018\\
    \emph{US Patent Publication US20200211135A1}, 2020
    \item 
    \textbf{Method and Apparatus for Detecting and Remediating Security Vulnerabilities in Computer Readable Code}\\
    \underline{Pieter De Cremer}, Matias Madou, Nathan Desmet, Colin Wong\\
    Patent application, under review with the examiner.\\
    \emph{US Patent Application 17/005,685}, 2020
    \item 
    \textbf{Method and Apparatus for Generating Security Vulnerability Guidelines}\\
    \underline{Pieter De Cremer}, Matias Madou, Nathan Desmet, Colin Wong\\
    Patent application, under review with the examiner.\\
    \emph{US Patent Application 17/005,729}, 2020
    \item 
    \textbf{Method and Apparatus for Adaptive Security Guidance}\\
    \underline{Pieter De Cremer}, Matias Madou, Nathan Desmet, Colin Wong\\
    Patent application, under review with the examiner.\\
    \emph{US Patent Application 17/469,636}, 2021
\end{itemize}
}

%\section{Conclusion}
%%Conclusion
%%What do these findings mean to the reader? Is this good or bad? How good or bad? How can readers use these results?
%Using the paved path methodology, and designing both education and tools to promote this methodology with the developer experience in mind, makes both the security team's and the developer team's jobs easier.
%
%
%With traditional security tools the security team is able to find many vulnerabilities in the code. However, it is still difficult to be sure whether or not \textit{all} vulnerabilities have been discovered, or even \textit{almost all}~\cite{kern2014securing}. With the paved path methodology, the potential for vulnerabilities is confined to the newly designed libraries. As a result it becomes much easier to reason about their absence. 
%
%
%Developer tools designed in line with the paved path methodology are able to overcome important inhibitors of developer productivity caused by traditional security tools. Because these developer tools no longer scan for vulnerabilities but instead assert that the paved path is followed, slow scanning speeds, the presence of false positives, and lack of remediation guidance are easily overcome.

\section{Perspectives}
%Perspectives
%What should we do next?
There is still progress to be made outside of this work, both in the education and tools for the paved path methodology as well as in different aspects of the cooperation between the security team and the development team.


Until now, education and tools were considered two separate things to provide to developers.
In reality, the border between these two is not that clearly defined and they blend over into each other. 


Developers often learn while doing, and the educational aspect of Sensei itself should not be underestimated. The approach of an \gls{its} can be extended to the tool. The information, and even guidance, that is provided by Sensei should not be identical for each user. Different information should be offered when teaching a new lesson compared to brushing up a forgotten one. Teaching new concepts should also depend on previous knowledge. It is easier to explain a new type of injection flaw (e.g. \gls{xml} injection) to a developer by drawing parallels with other injection flaws that they are already acquainted with (e.g. \gls{sql} injection).
Markings and remediation guidance should depend on the knowledge of the developer, and even that of other team members. Some critical security features might need more expertise, and the most efficient way forward as a team, could be for an uninformed developer to ask help from a more educated or experienced coworker.

But not only Sensei can benefit from this blended border with education.
Education can also be more targeted if it can integrate with Sensei and other developer tools. By observing which errors developers make in practice, a better picture of their understanding can be created.
By integrating with issue trackers, it is possible to keep track of the issues that developers are assigned to, and to design individual learning goals for each developer.
Integration with developer tools enables education to become even more relevant, efficient, and usable.

Another challenge that remains for the paved path methodology is applying it to existing, potentially large, legacy codebases. While the security team can still lay out a paved path for developers to follow, it is no easy task to refactor the existing code so that it adheres to this path. 
Extra care should be taken when designing the inherently safe wrapper library so that its uses match one to one as much as possible with the existing library. 

The paved path methodology helps the security team prevent and fix vulnerabilities at scale.
However, the security team still needs to tackle scalability in other facets of their collaboration with developers beyond the scope of this work.
One example is threat modeling.
It is impossible for one security expert to model threats for all software designs by up to 200 developers. 
Even though some approaches exist, they need wider adoption and more thorough evaluation before they can be endorsed.

%One such an approach is security surveys. These surveys are filled in by developers during the design phase and allow security experts to quickly determine which software designs contain most risk and should be threat modeled in more detail. 
%Integration testing platforms (e.g. Selenium) are another possibility. They allow security experts automate threat modeling tests that are widely applicable. 
%An example of such a test is verifying if multiple incorrect password attempts trigger a lockout mechanism correctly.

% so poetic
The paved path methodology by itself will not cause an enormous shift in software development, nor will it single-handedly prevent all software vulnerabilities in the future.
But it is an improvement.
With this method, we are paving the path towards secure development, and taking a step in the right direction.
A step towards a more human-centered future of software security, in a bigger journey to make security a shared responsibility among everyone involved in the software development process.